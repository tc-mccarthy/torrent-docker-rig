# ------------------------------------------------------------------------------
# docker-compose.yml
#
# Purpose:
#   Media/torrent stack with all VPN-routed services bound to a NordLynx
#   container ("nordlynx"). When the VPN restarts, any service labeled
#   `restart-with=nordlynx` is also restarted immediately to refresh sockets,
#   trackers, and long-lived connections. Autoheal + healthchecks provide
#   self-healing for transient tunnel blips.
#
# Key patterns:
#   - VPN gateway container: services route via `network_mode: service:vpn`.
#   - Autoheal: label `autoheal=true` + a meaningful healthcheck.
#   - Immediate restart on VPN restart: label `restart-with=nordlynx`.
#   - Event watcher: `vpn-restarter` listens to docker events for `nordlynx`
#     and restarts all containers with `restart-with=nordlynx`.
#
# Extend:
#   If you move any other service behind the VPN, add:
#     network_mode: service:vpn
#     labels:
#       - "autoheal=true"
#       - "restart-with=nordlynx"
#   and (ideally) a healthcheck that fails when the VPN is down.
# ------------------------------------------------------------------------------

version: "3.7"

services:
  # --------------------------------------------------------------------------
  # VPN GATEWAY
  # Exposes ports for the inner apps (via service:vpn network mode).
  # Healthcheck ensures tunnel + qbittorrent reachability before dependents start.
  # --------------------------------------------------------------------------
  vpn:
    image: ghcr.io/bubuntux/nordlynx
    container_name: nordlynx
    cap_add:
      - NET_ADMIN # Required for wireguard/nordlynx to manage routes/tunnel
    environment:
      - ALLOWED_IPS=0.0.0.0/0     # Allow full egress to the VPN from this docker network
      - NET_LOCAL=172.16.0.0/16   # Permit LAN access within this CIDR from inside VPN netns
      - PRIVATE_KEY=${NORDVPN_PRIVATE_KEY} # NordLynx key from Nord account
      # - QUERY="filters\[servers_groups\]\[identifier\]=legacy_p2p&filters\[country_id\]=228"
      - TZ                        # Logging timezone
      - CONNECT=p2p               # Ask for P2P-friendly servers
      - CATEGORY=p2p
      - TECHNOLOGY=nordlynx
    ports:
      # Ports exposed *on the VPN container* for services running inside it.
      # These map the inner apps' ports to the host.
      - 8088:8088   # qbittorrent web ui
      - 6881:6881   # qbittorrent tcp
      - 6881:6881/udp
      - 7878:7878   # radarr
      - 8989:8989   # sonarr
      - 9696:9696   # prowlarr
      - 4000:4000   # tinyMediaManager VNC (if enabled)
      - 9443:9443   # portainer behind VPN
      - 6767:6767   # bazarr
      - 8090:8080   # sabnzbd (usenet)
      - 5055:5055   # overseerr
      - 8181:8181   # tautulli
      - 9705:9705   # huntarr
    sysctls:
      - net.ipv6.conf.all.disable_ipv6=1 # Prefer IPv4-only to avoid leak/route confusion
      - net.ipv4.conf.all.rp_filter=2    # Loose reverse path filtering for policy routing
    volumes:
      - ./scripts:/scripts # healthcheck and utility scripts
    restart: unless-stopped
    labels:
      - "autoheal=true" # autoheal will check health and restart when failing
    healthcheck:
      # Script should verify both the VPN tunnel and a key dependent (e.g., qbit)
      test: bash ./scripts/vpn-health-check
      interval: 10s
      retries: 3
      timeout: 5s
      start_period: 60s
    networks:
      - default
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # TORRENT CLIENT (qBittorrent)
  # Runs inside the VPN namespace. Healthcheck should fail on tunnel loss.
  # Labeled for autoheal and restart-with-vpn for instant reconnection.
  # --------------------------------------------------------------------------
  torrent:
    image: linuxserver/qbittorrent
    container_name: qbittorrent
    network_mode: service:vpn # Route all traffic through the VPN container
    environment:
      - WEBUI_PORT=${QBIT_WEB_UI_PORT}
      - PUID=1000
      - GUID=1000
      - Umask=022
      - TZ
    volumes:
      - ${TORRENT_STORAGE}:${TORRENT_STORAGE} # downloads storage
      - ./config:/config                     # qBittorrent config
      - ./scripts:/scripts                   # healthcheck scripts
      - ./vuetorrent:/vuetorrent
    depends_on:
      vpn:
        condition: service_healthy # wait for tunnel
    labels:
      - "autoheal=true"
    restart: unless-stopped
    healthcheck:
      test: bash ./scripts/torrent-health-check
      interval: 10s
      retries: 0
      timeout: 5s
      start_period: 60s
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # TORRENT MONITOR (custom)
  # Monitors qBittorrent; not VPN-routed, but depends on torrent+redis.
  # --------------------------------------------------------------------------
  torrent-monitor:
    build: ./torrent-monitor
    container_name: torrent-monitor
    depends_on:
      - torrent
      - redis
    environment:
      - QB_API_URL=https://${TORRENT_SSL_HOST}/qbt
      - QB_USERNAME                 # supply at runtime
      - QB_PASSWORD                 # supply at runtime
      - REDIS_HOST=torrent-redis-local
      - REDIS_PORT=6379
      - TZ
    volumes:
      - ./torrent-monitor:/app
    restart: unless-stopped
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # AUTOHEAL
  # Periodically checks containers with "autoheal=true" and restarts if unhealthy.
  # --------------------------------------------------------------------------
  autoheal:
    image: willfarrell/autoheal:latest
    tty: true
    container_name: autoheal
    restart: always
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # NGINX REVERSE PROXY (public)
  # Terminates TLS for selected services; depends on torrent for qbit upstream.
  # Not VPN-routed (by design).
  # --------------------------------------------------------------------------
  proxy:
    image: nginx:1.23.3-alpine
    container_name: proxy
    restart: unless-stopped
    volumes:
      - ./nginx/sites-available:/etc/nginx/templates
      - ./certbot/etc:/ssl
      - ./transcode/output:/public/transcode
    ports:
      - "8080:80"
      - "8443:443"
    environment:
      - NGINX_PORT=80
      - NGINX_PORT_SSL=443
      - WEBUI_PORT=${QBIT_WEB_UI_PORT}
      - TORRENT_SSL_HOST
      - OVERSEERR_SSL_HOST
      - BACKUP_SSL_HOST
    depends_on:
      - torrent
    networks:
      - default
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # CERTBOT (DNS-01 via Cloudflare)
  # Generates wildcard/host certs for the reverse proxy.
  # --------------------------------------------------------------------------
  certbot:
    container_name: certbot
    image: certbot/dns-cloudflare
    volumes:
      - ./certbot/etc:/etc/letsencrypt
      - ./certbot/cloudflare.ini:/root/cloudflare.ini
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"
    command: >-
      certonly --dns-cloudflare
      --dns-cloudflare-credentials /root/cloudflare.ini
      --dns-cloudflare-propagation-seconds 30
      --email ${CLOUDFLARE_EMAIL}
      --agree-tos --no-eff-email
      --force-renewal
      -d ${TORRENT_SSL_HOST}
      -d ${OVERSEERR_SSL_HOST}
      -d ${BACKUP_SSL_HOST}

  # --------------------------------------------------------------------------
  # CLOUDFLARE DDNS CLIENTS
  # Keep public DNS records in sync with your IP / endpoints.
  # --------------------------------------------------------------------------
  ddns_torrent:
    container_name: ddns_torrent
    restart: unless-stopped
    image: oznu/cloudflare-ddns
    environment:
      - API_KEY=${CLOUDFLARE_API_KEY}
      - ZONE=${DDNS_ZONE}
      - SUBDOMAIN=${TORRENT_DDNS_SUBDOMAIN}
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"
  
  ddns_overseerr:
    container_name: ddns_overseerr
    restart: unless-stopped
    image: oznu/cloudflare-ddns
    environment:
      - API_KEY=${CLOUDFLARE_API_KEY}
      - ZONE=${DDNS_ZONE}
      - SUBDOMAIN=${OVERSEERR_DDNS_SUBDOMAIN}
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  ddns_backup:
    container_name: ddns_backup
    restart: unless-stopped
    image: oznu/cloudflare-ddns
    environment:
      - API_KEY=${CLOUDFLARE_API_KEY}
      - ZONE=${DDNS_ZONE}
      - SUBDOMAIN=${BACKUP_DDNS_SUBDOMAIN}
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # DUPLICATI (Backups)
  # --------------------------------------------------------------------------
  duplicati:
    image: lscr.io/linuxserver/duplicati:latest
    container_name: duplicati
    environment:
      - PUID=1000
      - PGID=1000
      - TZ
      - DUPLICATI__WEBSERVICE_PASSWORD=${BACKUP_PASSWORD}
      - SETTINGS_ENCRYPTION_KEY=${BACKUP_PASSWORD}
    volumes:
      - ./duplicati/config:/config
      - ${BACKUP_DESTINATION}:/backups
      - ${BACKUP_SOURCE}:/source
    ports:
      - 8200:8200
    restart: unless-stopped
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # TRANSCODE ENGINE (custom Node + FFmpeg)
  # Not VPN-routed: interacts with local media and infra.
  # --------------------------------------------------------------------------
  transcode:
    container_name: transcode
    build:
      context: ./transcode
    devices:
      - "/dev/dri:/dev/dri" # Intel Quick Sync
    environment:
      - TZ
      - TRANSCODE_PATHS
      - LOG_PRETTY=on
      - LOG_LEVEL=info
      - CHOKIDAR_USEPOLLING=1
      - NODE_OPTIONS=--max-old-space-size=57344 --enable-source-maps
      - MAX_MEMORY_SCORE
      - MAX_CPU_SCORE
      - CONCURRENT_FILE_CHECKS
      - CONCURRENT_INTEGRITY_CHECKS
      - ENV=${ENV:-prod}
      - TMDB_READ_ACCESS_TOKEN
      - COMPUTE_SCORE_FACTOR
    volumes:
      - ${TRANSCODE_STORAGE}:/source_media
      - ./transcode:/usr/app
      - /usr/app/node_modules
      - /usr/app/bin
    restart: unless-stopped
    depends_on:
      - redis
      - mongo
      - rabbitmq
    mem_limit: 56g
    memswap_limit: 64g
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # PLEX (host network for DLNA/UPnP discovery)
  # --------------------------------------------------------------------------
  plex:
    container_name: plex
    image: lscr.io/linuxserver/plex:latest
    network_mode: host
    devices:
      - "/dev/dri:/dev/dri" # Intel Quick Sync
    environment:
      - TZ
      - PUID=1000
      - PGID=1000
      - VERSION=docker
    volumes:
      - ${TRANSCODE_STORAGE}:${TRANSCODE_STORAGE}
      - ./plex:/config
    restart: unless-stopped
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # MONGO (local)
  # --------------------------------------------------------------------------
  mongo:
    container_name: torrent-mongo-local
    image: mongo:8.0.4-noble
    hostname: torrent-mongo-local
    ports:
      - 27017:27017
    volumes:
      - mongo_db_8:/data/db
    restart: always
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # SONARR (VPN-routed)
  # Waits for VPN, Prowlarr, Torrent; labeled for autoheal + instant restart.
  # --------------------------------------------------------------------------
  sonarr:
    container_name: sonarr
    image: lscr.io/linuxserver/sonarr:latest
    network_mode: service:vpn
    environment:
      - TZ
      - PUID=1000
      - PGID=1000
      - SERVICE_NAME=${SONARR_SERVICE_NAME}
      - SERVICE_PORT=${SONARR_SERVICE_PORT}
      - API_KEY=${SONARR_API_KEY}
    volumes:
      - ${SONARR_STORAGE}:${SONARR_STORAGE}
      - ./sonarr:/config
      - ./scripts:/scripts
    healthcheck:
      test: bash /scripts/arr-health-check
      interval: 10s
      retries: 3
      timeout: 5s
      start_period: 60s
    restart: unless-stopped
    labels:
      - "autoheal=true"
    depends_on:
      vpn:
        condition: service_healthy
      prowlarr:
        condition: service_healthy
      torrent:
        condition: service_healthy
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # RADARR (VPN-routed)
  # --------------------------------------------------------------------------
  radarr:
    container_name: radarr
    image: lscr.io/linuxserver/radarr:latest
    network_mode: service:vpn
    environment:
      - TZ
      - PUID=1000
      - PGID=1000
      - SERVICE_NAME=${RADARR_SERVICE_NAME}
      - SERVICE_PORT=${RADARR_SERVICE_PORT}
      - API_KEY=${RADARR_API_KEY}
    volumes:
      - ${RADARR_STORAGE}:${RADARR_STORAGE}
      - ./radarr:/config
      - ./scripts:/scripts
    healthcheck:
      test: bash /scripts/arr-health-check
      interval: 10s
      retries: 3
      timeout: 5s
      start_period: 60s
    restart: unless-stopped
    labels:
      - "autoheal=true"
    depends_on:
      vpn:
        condition: service_healthy
      prowlarr:
        condition: service_healthy
      torrent:
        condition: service_healthy
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # BAZARR (VPN-routed)
  # --------------------------------------------------------------------------
  bazarr:
    container_name: bazarr
    image: lscr.io/linuxserver/bazarr:latest
    network_mode: service:vpn
    environment:
      - TZ
      - PUID=1000
      - PGID=1000
      - SERVICE_NAME=${BAZARR_SERVICE_NAME}
      - SERVICE_PORT=${BAZARR_SERVICE_PORT}
      - API_KEY=${BAZARR_API_KEY}
    volumes:
      - ${BAZARR_STORAGE}:${BAZARR_STORAGE}
      - ./bazarr:/config
      - ./scripts:/scripts
    healthcheck:
      test: bash /scripts/arr-health-check
      interval: 10s
      retries: 3
      timeout: 5s
      start_period: 60s
    restart: unless-stopped
    labels:
      - "autoheal=true"
    depends_on:
      vpn:
        condition: service_healthy
      radarr:
        condition: service_healthy
      sonarr:
        condition: service_healthy
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # OVERSEERR (VPN-routed)
  # --------------------------------------------------------------------------
  overseerr:
    container_name: overseerr
    image: lscr.io/linuxserver/overseerr:latest
    network_mode: service:vpn
    environment:
      - TZ
      - PUID=1000
      - PGID=1000
      - SERVICE_NAME=${OVERSEERR_SERVICE_NAME}
      - SERVICE_PORT=${OVERSEERR_SERVICE_PORT}
    volumes:
      - ${OVERSEERR_STORAGE}:${OVERSEERR_STORAGE}
      - ./overseerr:/config
      - ./scripts:/scripts
    healthcheck:
      test: bash /scripts/arr-health-check
      interval: 10s
      retries: 3
      timeout: 5s
      start_period: 60s
    restart: unless-stopped
    labels:
      - "autoheal=true"
    depends_on:
      vpn:
        condition: service_healthy
      radarr:
        condition: service_healthy
      sonarr:
        condition: service_healthy
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # PROWLARR (VPN-routed)
  # --------------------------------------------------------------------------
  prowlarr:
    container_name: prowlarr
    image: lscr.io/linuxserver/prowlarr:latest
    network_mode: service:vpn
    environment:
      - TZ
      - PUID=1000
      - PGID=1000
      - SERVICE_NAME=${PROWLARR_SERVICE_NAME}
      - SERVICE_PORT=${PROWLARR_SERVICE_PORT}
      - API_KEY=${PROWLARR_API_KEY}
    volumes:
      - ${PROWLARR_STORAGE}:${PROWLARR_STORAGE}
      - ./prowlarr:/config
      - ./scripts:/scripts
    healthcheck:
      test: bash /scripts/arr-health-check
      interval: 10s
      retries: 3
      timeout: 5s
      start_period: 10s
    labels:
      - "autoheal=true" 
    restart: unless-stopped
    depends_on:
      vpn:
        condition: service_healthy
      torrent:
        condition: service_healthy
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # TAUTULLI (local analytics, not VPN-routed)
  # --------------------------------------------------------------------------
  tautulli:
    container_name: tautulli
    image: lscr.io/linuxserver/tautulli:latest
    environment:
      - TZ
      - PUID=1000
      - PGID=1000
    volumes:
      - ./tautulli/config:/config
    restart: unless-stopped
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"
  
  # --------------------------------------------------------------------------
  # HUNTARR (VPN-routed)
  # Typically exits on network loss -> Docker restarts quickly.
  # Still labeled to follow VPN restarts immediately.
  # --------------------------------------------------------------------------
  huntarr:
    container_name: huntarr
    image: huntarr/huntarr:latest
    network_mode: service:vpn
    environment:
      - TZ
      - PUID=1000
      - PGID=1000
    volumes:
      - ./huntarr/config:/config
    restart: unless-stopped
    labels:
      - "autoheal=true"
    depends_on:
      vpn:
        condition: service_healthy
      sonarr:
        condition: service_healthy
      radarr:
        condition: service_healthy
      prowlarr:
        condition: service_healthy
      torrent:
        condition: service_healthy
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # TINYMEDIA MANAGER (VPN-routed)
  # --------------------------------------------------------------------------
  tmm:
    container_name: tinymediamanager
    image: tinymediamanager/tinymediamanager:latest
    network_mode: service:vpn
    environment:
      - TZ
      - USER_ID=1000
      - GROUP_ID=1000
      - PASSWORD=${TMM_PASSWORD}
    volumes:
      - ${TMM_STORAGE}:${TMM_STORAGE}
      - ./tmm:/data
      - ./scripts:/scripts
      - ./tmm/launcher-extra.yml:/app/launcher-extra.yml
    restart: unless-stopped
    healthcheck:
      test: bash /scripts/tmm-health-check
      interval: 10s
      retries: 3
      timeout: 5s
      start_period: 60s
    labels:
      - "autoheal=true"
    depends_on:
      vpn:
        condition: service_healthy
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # PORTAINER (VPN-routed UI)
  # Labeled to follow VPN restarts so its session reconnects promptly.
  # --------------------------------------------------------------------------
  portainer:
    container_name: portainer
    image: portainer/portainer-ce:latest
    network_mode: service:vpn
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_db:/data
    depends_on:
      vpn:
        condition: service_healthy
    restart: unless-stopped
    labels:
      - "autoheal=true"
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # REDIS (local cache/queue)
  # --------------------------------------------------------------------------
  redis:
    container_name: torrent-redis-local
    image: redis:latest
    hostname: torrent-redis-local
    ports:
      - 6379:6379
    volumes:
      - redis_data:/data
    restart: always
    entrypoint: redis-server --appendonly yes
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"
    
  # --------------------------------------------------------------------------
  # SAMBA (host network for LAN file shares)
  # --------------------------------------------------------------------------
  samba:
    container_name: samba
    image: crazymax/samba:latest
    network_mode: host
    environment:
      - TZ
      - SAMBA_USER
      - SAMBA_PASSWORD
      - SAMBA_GROUP
    volumes:
      - ${SAMBA_STORAGE}:/samba/public
      - ./samba:/data
    restart: always
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # SABNZBD / USENET (VPN-routed)
  # --------------------------------------------------------------------------
  usenet:
    image: linuxserver/sabnzbd
    container_name: usenet
    network_mode: service:vpn
    environment:
      - PUID=1000
      - GUID=1000
      - Umask=022
      - TZ
    volumes:
      - ${USENET_STORAGE}:${USENET_STORAGE}
      - ./sabnzbd:/config
      - ./scripts:/scripts
    depends_on:
      vpn:
        condition: service_healthy
    labels:
      - "autoheal=true"
    restart: unless-stopped
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

  # --------------------------------------------------------------------------
  # GLANCES (web UI monitoring)
  # --------------------------------------------------------------------------
  monitoring:
    image: nicolargo/glances:latest-full
    container_name: monitoring
    environment:
      - PUID=1000
      - PGID=1000
      - TZ
      - GLANCES_OPT=-w
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock      
    ports:
      - 61208:61208
    restart: unless-stopped
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"
  
  # --------------------------------------------------------------------------
  # RABBITMQ (management + AMQP)
  # --------------------------------------------------------------------------
  rabbitmq:
    hostname: rabbitmq
    container_name: rabbitmq
    image: rabbitmq:4.0.9-management-alpine
    ports:
      - "15672:15672" # mgmt UI
      - "5672:5672"   # amqp
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq/mnesia/
    restart: always
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"
  
  # --------------------------------------------------------------------------
  # MEMCACHED
  # --------------------------------------------------------------------------
  memcached:
    container_name: memcached
    image: memcached:latest
    ports:
      - "11211:11211"
    restart: always
    logging: 
      driver: "json-file"
      options: 
        max-size: "200k"
        max-file: "10"

# ------------------------------------------------------------------------------
# VOLUMES
# ------------------------------------------------------------------------------
volumes:
  mongo_db_8:
  portainer_db:
  redis_data:
  rabbitmq_data:

# ------------------------------------------------------------------------------
# NETWORKS
# Using an external pre-created network "torrent-rig" to keep container names
# stable and allow sidecar/proxy composition across multiple stacks if needed.
# ------------------------------------------------------------------------------
networks:
  default:
    name: torrent-rig
    external: true
